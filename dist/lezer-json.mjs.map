{
  "version": 3,
  "sources": ["http-url:https://jspm.dev/npm:@lezer/common@0.15.12", "http-url:https://jspm.dev/npm:@lezer/lr@0.15.8", "index.es.mjs"],
  "sourcesContent": ["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip through\n    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't\n    /// automatically enter mounted nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, 1 /* Full */);\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor(), get = () => c.node;;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to, get);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, overlays);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(node, _from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this.node = node;\n        this._from = _from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get from() { return this._from; }\n    get to() { return this._from + this.node.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent._from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & 2 /* NoEnterBuffer */)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent.node.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, overlays = true, buffers = true) {\n        let mounted;\n        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return this.node; }\n    toTree() { return this.node; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, overlays, buffers = true) {\n        if (!buffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, overlays = true, buffers = true) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));\n        return buffers ? this.enterChild(1, pos, side) : false;\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                    let child = parent.node.children[i];\n                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from))\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.fullCursor();\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, MountedTree, NodeProp, NodeSet, NodeType, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n\n//# sourceMappingURL=common@0.15.12.map", "import { Tree, NodeProp, Parser, NodeSet, NodeType, DefaultBufferLength } from './common@0.15';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            // Zero-depth reductions are a special case\u2014they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsing\u2014when looking forward\u2014or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length)\n            return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        // Do a binary search on the state's edges\n        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.fullCursor();\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        tokenizer.token(this.stream.reset(stack.pos, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = Math.min(stack.p.stream.end, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 2), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // \u2654, \u2655, \u2656, \u2657, \u2658, \u2659, \u2660, \u2661, \u2662, \u2663, \u2664, \u2665, \u2666, \u2667\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n\n//# sourceMappingURL=lr@0.15.8.map", "import { LRParser } from 'https://jspm.dev/@lezer/lr';\nimport { NodeProp } from 'https://jspm.dev/@lezer/common';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 13,\n  states: \"$bO]QPOOOOQO'#Cd'#CdOtQQO'#CgO!PQPO'#ClOOQO'#Cr'#CrQOQPOOOOQO'#Ci'#CiO!WQPO'#ChO!]QPO'#CtOOQO,59R,59RO!eQPO,59RO!jQPO'#CxOOQO,59W,59WO!rQPO,59WO]QPO,59SOwQQO'#CmO!wQPO,59`OOQO1G.m1G.mO]QPO'#CnO#PQPO,59dOOQO1G.r1G.rOOQO1G.n1G.nOOQO,59X,59XOOQO-E6k-E6kOOQO,59Y,59YOOQO-E6l-E6l\",\n  stateData: \"#X~OeOSPOSQOS~OSSOTSOUSOVSOYQO_ROgPO~OXXOgUOiUO~O^[O~P]Oj^O~Ok_OXhX~OXaO~OkbO^lX~O^dO~Ok_OXha~OkbO^la~O\",\n  goto: \"!nmPPPPPPPPnPPntzPPn!O!UPPP![P!hPPP!kXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \"\u26A0 LineComment BlockComment JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 28,\n  nodeProps: [\n    [NodeProp.openedBy, 9,\"{\",14,\"[\"],\n    [NodeProp.closedBy, 10,\"}\",15,\"]\"]\n  ],\n  skippedNodes: [0,1,2],\n  repeatNodeCount: 2,\n  tokenData: \"Au~RtOX#cXY$mYZ$mZ]#c]^$m^p#cpq$mqr#crs$rsw#cwx'Ox|#c|})t}!O)y!O!P1P!P!Q1o!Q!R2x!R![3y![!]4}!]!}#c!}#O5S#O#P#c#P#Q5X#Q#S#c#S#T5^#T#Y#c#Y#Z8S#Z#b#c#b#c;s#c#h#c#h#i>o#i#o#c#o#pAk#p#q#c#q#rAp#r~#cQ#fWOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]~$OQ$TWiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]~$O~$rOe~~$uUpq$rqr$rrs%Xs#O$r#O#P%^#P~$r~%^Og~~%aXrs$r!P!Q$r#O#P$r#U#V$r#Y#Z$r#b#c$r#f#g$r#h#i$r#i#j%|~&PR!Q![&Y!c!i&Y#T#Z&Y~&]R!Q![&f!c!i&f#T#Z&f~&iR!Q![&r!c!i&r#T#Z&r~&uR!Q![$r!c!i$r#T#Z$r~'RVpq'Oqr'Osw'Owx'hx#O'O#O#P(S#P~'O~'mVg~pq'Oqr'Osw'Owx'hx#O'O#O#P(S#P~'O~(VXrs'O!P!Q'O#O#P'O#U#V'O#Y#Z'O#b#c'O#f#g'O#h#i'O#i#j(r~(uR!Q![)O!c!i)O#T#Z)O~)RR!Q![)[!c!i)[#T#Z)[~)_R!Q![)h!c!i)h#T#Z)h~)kR!Q!['O!c!i'O#T#Z'O~)yOk~R)|[OX$OXY#cZ]$O]^#c^p$Opq#cq!O$O!O!P*r!P!Q$O!Q!R.v!R![/y!]~$OR*wXiQOX$OXY#cZ]$O]^#c^p$Opq#cq!Q$O!Q![+d!]~$OR+k]VPiQOX$OXY#cZ]$O]^#c^p$Opq#cq!Q$O!Q![+d!]!g$O!g!h,d!h#X$O#X#Y,d#Y~$OR,i]iQOX$OXY#cZ]$O]^#c^p$Opq#cq{$O{|-b|}$O}!O-b!O!Q$O!Q![.S!]~$OR-gXiQOX$OXY#cZ]$O]^#c^p$Opq#cq!Q$O!Q![.S!]~$OR.ZXVPiQOX$OXY#cZ]$O]^#c^p$Opq#cq!Q$O!Q![.S!]~$OR.}^VPiQOX$OXY#cZ]$O]^#c^p$Opq#cq!O$O!O!P+d!P![$O!]!g$O!g!h,d!h#X$O#X#Y,d#Y~$OR0Q_VPiQOX$OXY#cZ]$O]^#c^p$Opq#cq!O$O!O!P+d!P!Q$O!Q![/y!]!g$O!g!h,d!h#X$O#X#Y,d#Y~$OR1SXOX$OXY#cZ]$O]^#c^p$Opq#cq!Q$O!Q![+d!]~$O~1rQz{1x!P!Q2m~1{ROz1xz{2U{~1x~2XTOz1xz{2U{!P1x!P!Q2h!Q~1x~2mOQ~~2rQP~OY2mZ~2mR2}^VPOX$OXY#cZ]$O]^#c^p$Opq#cq!O$O!O!P+d!P![$O!]!g$O!g!h,d!h#X$O#X#Y,d#Y~$OR4O_VPOX$OXY#cZ]$O]^#c^p$Opq#cq!O$O!O!P+d!P!Q$O!Q![/y!]!g$O!g!h,d!h#X$O#X#Y,d#Y~$O~5SOj~~5XO_~~5^O^~~5aVpq5^qr5^s#O5^#O#P5v#P#S5^#S#T7h#T~5^~5yXrs5^!P!Q5^#O#P5^#U#V5^#Y#Z5^#b#c5^#f#g5^#h#i5^#i#j6f~6iR!Q![6r!c!i6r#T#Z6r~6uR!Q![7O!c!i7O#T#Z7O~7RR!Q![7[!c!i7[#T#Z7[~7_R!Q![5^!c!i5^#T#Z5^~7mVg~pq5^qr5^s#O5^#O#P5v#P#S5^#S#T7h#T~5^R8VYOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#T$O#T#U8u#U~$OR8zYiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#`$O#`#a9j#a~$OR9oYiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#g$O#g#h:_#h~$OR:dYiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#X$O#X#Y;S#Y~$OR;ZWTPiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]~$OR;vYOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#i$O#i#j<f#j~$OR<kYiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#`$O#`#a=Z#a~$OR=`YiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#`$O#`#a>O#a~$OR>VWUPiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]~$OR>rYOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#f$O#f#g?b#g~$OR?gYiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#i$O#i#j@V#j~$OR@[YiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]#X$O#X#Y@z#Y~$ORARWSPiQOX$OXY#cZ]$O]^#c^p$Opq#cq![$O!]~$O~ApOY~~AuOX~\",\n  tokenizers: [0, 1],\n  topRules: {\"JsonText\":[0,3]},\n  tokenPrec: 0\n});\n\nexport { parser };\n"],
  "mappings": "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",
  "names": []
}
